# 主从模式

* 主进程不负责具体业务的处理，而负责调度或管理工作进程，取向与稳定
* 工作进程负责具体的业务处理，因为业务的多样性、甚至需要多人完成，所以稳定性更需要关注

### IPC
* 让不同破名的进程能够相互访问资源，并进行协调工作
* 实现技术: 命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等等
* Node中使用 libuv 的管道技术进行实现
* IPC连接过程: 
    1. 父进程准备创建子进程前，先创建一个IPC通道
    2. 再实际创建子进程
    3. 通过全局变量`NODE_CHANNEL_FD`告诉子进程这个IPC的文件描述符
    4. 子进程在启动过程中，主动去连接这个IPC
* IPC 实现的是双向通信，因为其底层的实现机制为 `Domain Socket`，所以与网络中的`socket`表现类似。

### 句柄模式
* 使用代理模式 实现 主从架构
    1. 主进程监听80端口，子进程监听其他不同的端口，可以实现基本的组主从架构
    2. 但客户端到主进程，主进程到子进程，都分别要占用一个文件描述符。是理想情况的双倍。
* 解决代理模式的问题
    1. 父进程接收到socket请求之后，将socket发送给工作进程，而不是与工作进程之间建立新的socket连接来转发数据
    2. socket发送给子进程后，父进程对应的服务器也会关闭
    3. Node 进程间通信，实际上只能够发送消息，不能够传递对象
    4. 能够实现tcp服务器的传递，其实只是子进程根据父进程发送来的消息类型，重新创建的Tcp服务器而已
* 共同监听端口问题
    1. Node 底层对每个监听端口设置了 `SO_REUSEADDR` 选项，使得不同进程可以就相同的网卡和端口进行监听
    2. 对于主进程通过send语句发送给子进程的的句柄，子进程还原出来的tcp服务器的文件描述符是一致的，所以监听相同的端口，不会引起异常
    3. 多个进程监听相同的端口时，文件描述符同一个时间只能够被某个进程所使用。
    4. 也就是说，面对网络请求，只有一个幸运的进程能够抢占连接进行服务(抢占式的)。